# Package Base
[![Build Status](https://api.travis-ci.org/WsdlToPhp/PackageBase.svg)](https://travis-ci.org/WsdlToPhp/PackageBase)
[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/WsdlToPhp/PackageBase/badges/quality-score.png)](https://scrutinizer-ci.com/g/WsdlToPhp/PackageBase/)
[![Code Coverage](https://scrutinizer-ci.com/g/WsdlToPhp/PackageBase/badges/coverage.png)](https://scrutinizer-ci.com/g/WsdlToPhp/PackageBase/)
[![Dependency Status](https://www.versioneye.com/user/projects/5571b32b6634650018000011/badge.svg)](https://www.versioneye.com/user/projects/5571b32b6634650018000011)

## Main features
This project contains base classes used as parent class by the generated classes from [PackageGenerator](https://github.com/WsdlToPhp/PackageGenerator):
- [AbstractStructBase](#abstractstructbase)
- [AbstractStructArrayBase](#abstractstructarraybase)
- [AbstractSoapClientBase](#abstractsoapclientbase)
- [SoapClientInterface](#soapclientinterface)

## How tos
### AbstractStructBase
#### Description
This class is the base class for any ```StructType``` class generated by [PackageGenerator](https://github.com/WsdlToPhp/PackageGenerator).
It defines three methods:
- **__set_state($array)**: Usefull when you load the string representation of an object that you stored using ```var_export```. It also allows you to ease the instanciation of an object that contains many properties which would be hard to instanciate using the __construct method. You can see ```__set_state``` as an hydratation method.
- **_set($name, $value)**: As magic method ```__set``` but used by the ```__set_state``` method. Plus, defining ```__set``` method on used class by the classmap option for the SoapClient breaks the correct hydratation of your received objects.
- **_get($name)**: As magic method ```__get```. Used by ```AbstractStructArrayBase``` class

#### Usage
```php
$item = \Api\StructType\Item::__set_state(array(
    'id' => 1,
    'name' => 'Entity #1',
    'label' => 'Entity #1',
    '_href' => 'http://www.entity.com',
));
// $item is now an \Api\StructType\Item object
```

### AbstractStructArrayBase
#### Description
This class is the base class for any ```ArrayType``` class generated by [PackageGenerator](https://github.com/WsdlToPhp/PackageGenerator).
Its goal is to provide utility/handful methods by implementing ```ArrayAccess```, ```Iterator``` and ```Countable``` PHP interfaces.

#### Usage
As soon as you have an element that is an array of items such as:
```php
$items = \Api\ArrayType\Items::__set_state(array(
    'items' => array(
        \Api\StructType\Item::__set_state(array(
            'id' => 1,
            'name' => 'Entity #1',
            'label' => 'Entity #1',
            '_href' => 'http://www.entity-1.com',
        ),
        \Api\StructType\Item::__set_state(array(
            'id' => 2,
            'name' => 'Entity #2',
            'label' => 'Entity #2',
            '_href' => 'http://www.entity-2.com',
        ),
        \Api\StructType\Item::__set_state(array(
            'id' => 3,
            'name' => 'Entity #3',
            'label' => 'Entity #3',
            '_href' => 'http://www.entity-3.com',
        ),
    )
));
// 'items' is the unique property of the object
// Its name is returned by the getAttributeName method
// defined in the generated \Api\ArrayType\Items class
```
- **You MUST call first** ```initInternArray``` method on your ArrayType object otherwise you'll get nothing working for the implemented methods:
```php
$items->initInternArray();
```
- then you can call ```count```, ```length``` methods: gives you the number of items contained by your object
- you can iterate through the items:
```php
foreach ($items as $item) {
    // $items->current() and $item is an \Api\StructType\Item object
    // $items->key() is the current index
}
```
- you can get the first item:
```php
$items->first();
```
- you can get the last item:
```php
$items->last();
```
- you can get any item:
```php
$items->item($index);
```
- you can add a new item:
```php
$items->add(\Api\StructType\Item::__set_state(array(
    'id' => 4,
    'name' => 'Entity #4',
    'label' => 'Entity #4',
    '_href' => 'http://www.entity-4.com',
)));
```
- you can even reset the items:
```php
$items->initInternArray(array(
    \Api\StructType\Item::__set_state(array(
        'id' => 0,
        'name' => 'Entity #0',
        'label' => 'Entity #0',
        '_href' => 'http://www.entity-0.com',
    ),
    \Api\StructType\Item::__set_state(array(
        'id' => 1,
        'name' => 'Entity #1',
        'label' => 'Entity #1',
        '_href' => 'http://www.entity-1.com',
    ),
    \Api\StructType\Item::__set_state(array(
        'id' => 2,
        'name' => 'Entity #2',
        'label' => 'Entity #2',
        '_href' => 'http://www.entity-2.com',
    ),
));
```

### AbstractSoapClientBase
#### Description
This class is the base class for any ```ServiceType``` class generated by [PackageGenerator](https://github.com/WsdlToPhp/PackageGenerator).
Its goal is to provide utility/handful methods by implementing ```SoapClientInterface```.
It's basically a decorator design pattern as the class has the ```SoapClient``` object as a static property in order to be able apply methods on it. It is static property in order to have a singleton between multiple calls. It can be reset by passing true as the second parameter.

#### Usage
Let's say you have this type of generate ServiceType's class:
```php
namespace Api\ServiceType;
class ApiUpdate extends AbstractSoapClientBase
{
    public function UpdateBulkOrder(\Api\StructType\ApiUpdateBulkOrder $parameters)
    {
        try {
            $this->setResult(self::getSoapClient()->UpdateBulkOrder($parameters));
            return $this->getResult();
        } catch (\SoapFault $soapFault) {
            $this->saveLastError(__METHOD__, $soapFault);
            return false;
        }
    }
}
```
You can do:
```php
use \WsdlToPhp\PackageBase\AbstractSoapClientBase;
$options = array(
    AbstractSoapClientBase::WSDL_URL => '__WSDL_URL__',
    AbstractSoapClientBase::WSDL_CLASSMAP => \Api\ApiClassMap::classMap(),
);
// sets the first instance of SoapClient within  AbstractSoapClientBase
$update = new \Api\ServiceType\ApiUpdate($options);
// resets the SoapClient instance
$update = new \Api\ServiceType\ApiUpdate($options, true);
```
Then call any of these base methods:
- **getResult**: return the actual response as an object. The object's class should be a generated class
- **getLastRequest($asDomDocument = false)**: returns either the XML string version or the ```DOMDocument``` version of the request
- **getLastResponse($asDomDocument = false)**: returns either the XML string version or the ```DOMDocument``` version of the response
- **getLastRequestHeaders($asArray = false)**: returns either the HTTP request's headers as a string or as an array (each HTTP header is parsed)
- **getLastResponseHeaders($asArray = false)**: returns either the HTTP response's headers as a string or as an array
- **getLastError**: automatically populated with an error when ```$this->saveLastError(__METHOD__, $soapFault)``` is called
- **getLastErrorForMethod($methoName)** : returns the error associated to the called method. It should return a ```SoapFault``` object
```php
$result = $update->UpdateBulkOrder(new \Api\StructType\ApiUpdateBulkOrder())
if ($result !== false) {
    echo "\nThis is the result as an object:" . print_r($update->getResult(), true);
    // Actually $result is the same data than $update->getResult()
} else {
    echo "\nThis is the XML request:" . $update->getLastRequest(false);
    echo "\nThese are the request's headers:" . $update->getLastRequestHeaders(false);
    echo "\nThis is the XML response:" . $update->getLastResponse(false);
    echo "\nThese are the response's headers:" . $update->getLastResponseHeaders(false);
    echo "\nThese are the last errors:" . print_r($update->getLastError(), true);
    echo "\nThis is the current error:" . print_r($update->getLastErrorForMethod('\Api\ServiceType\ApiUpdate::UpdateBulkOrder'), true);
}
```
You have additional methods such as:
- **setSoapHeader($nameSpace, $name, $data, $mustUnderstand = false, $actor = null)**: it provides a way to redefine SoapHeaders
```php
// A sample of its usage in the generated ServiceType class
public function setSoapHeaderCSPCHD(\Api\StructType\ApiCSPCHD $cSPCHD, $nameSpace = 'http://tempuri.org', $mustUnderstand = false, $actor = null)
{
    return $this->setSoapHeader($nameSpace, 'CSPCHD', $cSPCHD, $mustUnderstand, $actor);
}
```
- **setHttpHeader($headerName, $headerValue)**: an easy way to define your proper HTTP headers that must be sent
- **setLocation($location)**: Sets the location of the Web service to use

### SoapClientInterface
#### Description
This interface is the base interface that must be used to define a new ```SoapClient``` base class for any ```ServiceType``` class generated by [PackageGenerator](https://github.com/WsdlToPhp/PackageGenerator).

#### What has to be implemented?
Here are the constants defined by this interface and their utility:
- **DEFAULT_SOAP_CLIENT_CLASS = '\SoapClient'**: this is the default ```SoapClient``` class that is used to send the request. Feel free to override it if you want to use another ```SoapClient``` class
- **OPTION_PREFIX**: this is the prefix used for any constant's option name
- **WSDL_URL**: option index used to pass the WSDL url
- **WSDL_CLASSMAP**: the classmap's array
- **WSDL_LOGIN**: the basic authentication's login
- **WSDL_PASSWORD**: the basic authentication's password
- **WSDL_TRACE**: tracing of request so faults can be backtraced. This defaults to ```true```
- **WSDL_EXCEPTIONS**: boolean value defining whether soap errors throw exceptions of type SoapFault
- **WSDL_CACHE_WSDL**: option is one of ```WSDL_CACHE_NONE```, ```WSDL_CACHE_DISK```, ```WSDL_CACHE_MEMORY``` or ```WSDL_CACHE_BOTH```
- **WSDL_STREAM_CONTEXT**: a [resource](http://php.net/manual/en/language.types.resource.php) for [context](http://php.net/manual/en/context.php)
- **WSDL_SOAP_VERSION**: one of either ```SOAP_1_1``` or ```SOAP_1_2``` to select SOAP 1.1 or 1.2, respectively. If omitted, 1.1 is used
- **WSDL_COMPRESSION**: allows to use compression of HTTP SOAP requests and responses
- **WSDL_ENCODING**: internal character encoding. This option does not change the encoding of SOAP requests (it is always utf-8), but converts strings into it
- **WSDL_CONNECTION_TIMEOUT**: defines a timeout in seconds for the connection to the SOAP service. This option does not define a timeout for services with slow responses. To limit the time to wait for calls to finish the [default_socket_timeout](http://php.net/manual/en/filesystem.configuration.php#ini.default-socket-timeout) setting is available
- **WSDL_TYPEMAP**: array of type mappings. Type mapping is an array with keys type_name, type_ns (namespace URI), from_xml (callback accepting one string parameter) and to_xml (callback accepting one object parameter)
- **WSDL_USER_AGENT**: specifies string to use in User-Agent header
- **WSDL_FEATURES**: a bitmask of ```SOAP_SINGLE_ELEMENT_ARRAYS```, ```SOAP_USE_XSI_ARRAY_TYPE```, ```SOAP_WAIT_ONE_WAY_CALLS```
- **WSDL_KEEP_ALIVE**: a boolean value defining whether to send the Connection: Keep-Alive header or Connection: close
- **WSDL_PROXY_HOST**: your pxoxy hostname
- **WSDL_PROXY_PORT**: your proxy port
- **WSDL_PROXY_LOGIN**: your proxy login
- **WSDL_PROXY_PASSWORD**: your proxy password
- **WSDL_LOCAL_CERT**: your local certificate content (as a string)
- **WSDL_PASSPHRASE**: your local passphrase content (as a string)
- **WSDL_AUTHENTICATION**: authentication method may be either ```SOAP_AUTHENTICATION_BASIC``` (default) or ```SOAP_AUTHENTICATION_DIGEST```
- **WSDL_SSL_METHOD**: one of ```SOAP_SSL_METHOD_TLS```, ```SOAP_SSL_METHOD_SSLv2```, ```SOAP_SSL_METHOD_SSLv3``` or ```SOAP_SSL_METHOD_SSLv23```

Here are the methods that must be implemented and why:
- **__construct(array $wsdlOptions = array(), $resetSoapClient = true)**: the constructor must be able to handl one of the listed constants above
- **getSoapClient()**: must return the ```SoapClient``` object that is responsible fo sending the requests.
- **setSoapHeader($nameSpace, $name, $data, $mustUnderstand = false, $actor = null)**: look to [AbstractSoapClientBase](#abstractsoapclientbase) part that details this method. Basically, it allows to define ```SoapHeader```s for the request
- **getLastError()**: must return the last error, its format is up to you
- **saveLastError($methoName, \SoapFault $soapFault)**: look to [AbstractSoapClientBase](#abstractsoapclientbase) part that details this method. Basically, it must allow to store a catched ```Soapfault``` object when a request has failed
- **getResult()**: should return the Soap Web Service response, it's up to you
- **setResult($result)**: must accept any parameter type as it should received the Soap Web Service response

**If you do not want to implement all these methods, you can too create your own class that inheits from the our [AbstractSoapClientBase](#abstractsoapclientbase) class.**

## Need improvements for these classes?
Feel free to make some pull requests. We'll study them and let you know when it can be integrated.

## Unit tests
You can run the unit tests with the following command:
```
    $ cd /path/to/src/WsdlToPhp/PackageBase/
    $ composer install
    $ phpunit
```